/*!
 * idb.js IndexedDB wrapper v3.0
 * Licensed under the MIT license
 * Copyright (c) 2019 Lukas Jans
 * https://github.com/luniverse/idb
 */
IDB=class e{static promise(e){return new Promise((t,r)=>{e.onerror=(()=>r(e.error)),e.onsuccess=(()=>t(e.result))})}static open(e,t={}){const r=indexedDB.open(t.name||"IDB",t.version||1);this.connection=this.promise(r),r.onupgradeneeded=(n=>{const s=r.result;for(const t of s.objectStoreNames)e[t]||s.deleteObjectStore(t);for(const[t,r]of Object.entries(e))s.objectStoreNames.contains(t)||s.createObjectStore(t,r);t.upgrade&&t.upgrade(n)});for(const t of Object.keys(e))this[t]=new this.Table(t)}static get Table(){return class{constructor(e){this.name=e}transaction(t){return e.connection.then(r=>{const n=r.transaction(this.name,"readwrite").objectStore(this.name),s=t(n);return s instanceof Promise?s:e.promise(s)})}get(e){return this.transaction(t=>t.get(e))}put(e,t){return this.transaction(r=>r.put(e,t))}delete(e){return this.transaction(t=>t.delete(e))}clear(){return this.transaction(e=>e.clear())}all(e){return this.transaction(t=>new Promise((r,n)=>{const s=[],o=t.openCursor();o.onerror=(()=>n(o.error)),o.onsuccess=(()=>{const t=o.result;t?(s.push(t.value),t.continue()):r(e?s.filter(e):s)})}))}}}};